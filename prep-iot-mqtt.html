<html lang="en-US"><head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1"/>

<title>TTM4175</title>
<meta property="og:title" content="TTM4115">
<meta property="og:locale" content="en_US">
<meta name="description" content="Design of Communicating Systems">
<meta property="og:description" content="Design of Communicating Systems">


<!--<link rel="stylesheet" type="text/css" href="style.css" />-->
<link href="https://fonts.googleapis.com/css?family=Merriweather:400,400italic,700,700italic|Source+Code+Pro|Source+Sans+Pro:200,300,400,600,400italic,600italic|Rock+Salt" rel="stylesheet" type="text/css">


<link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/css/bootstrap.min.css" integrity="sha384-MCw98/SFnGE8fJT3GXwEOngsV7Zt27NXFoaoApmYm81iuXoPkFOJwJ8ERdknLPMO" crossorigin="anonymous">
<script src="https://code.jquery.com/jquery-3.3.1.slim.min.js" integrity="sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.3/umd/popper.min.js" integrity="sha384-ZMP7rVo3mIykV+2+9J3UJ46jBk0WLaUAdn689aCwoqbBJiSnjAK/l8WvCWPIPm49" crossorigin="anonymous"></script>
<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/js/bootstrap.min.js" integrity="sha384-ChfqqxuZUCnJSK3+MXmPNIyE6ZbWh2IMqE241rYiqJxyMiZ6OW/JmZQ5stwEULTy" crossorigin="anonymous"></script>


<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.6.1/css/all.css" integrity="sha384-gfdkjb5BdAXd+lj+gudLWI+BXq4IuLW5IT+brZEZsLFm++aCMlF1V92rMkPaX4PP" crossorigin="anonymous">

<link rel="stylesheet" type="text/css" href="assets/style.css" />

<!--<script src="jquery-1.10.1.min.js"></script>-->
<script src="assets/script-aside.js"></script>
</head>
<body id="top">

<nav class="navbar navbar-expand-md navbar-dark " style="background-color:#666666"#2B65EC"> <!-- fixed-top -->
        <ul class="nav nav-pills">
        <li class="nav-item">
    <a class="nav-link" href="index.html" style="font-weight: bold")>TTM4175</a>
  </li>

  <li class="nav-item dropdown">
    <a class="nav-link dropdown-toggle" data-toggle="dropdown" href="#" role="button" aria-haspopup="true" aria-expanded="false">Teknostart</a>
    <div class="dropdown-menu">
      <a class="dropdown-item" href="material/2019-08-15-ikt-intro.pdf">IKT Introduksjon (PDF)</a>
      <div class="dropdown-divider"></div>
      <a class="dropdown-item" href="day1.html">Dag 1: Raspberry Pi</a>
      <a class="dropdown-item" href="day2.html">Dag 2: Linux</a>
      <a class="dropdown-item" href="day3.html">Dag 3: IP, SSH og HTML</a>
      <a class="dropdown-item" href="day4.html">Dag 4: Webserver</a>
      <a class="dropdown-item" href="day5.html">Dag 5: Recap</a>
    </div>
  </li>
        
  <li class="nav-item dropdown">
    <a class="nav-link dropdown-toggle" data-toggle="dropdown" href="#" role="button" aria-haspopup="true" aria-expanded="false">Preparation</a>
    <div class="dropdown-menu">
      <a class="dropdown-item disabled"><strong>Networking</strong></a>
      <a class="dropdown-item" href="prep-networking-1.html">IPs, Subnets and Routing</a>
      <a class="dropdown-item" href="prep-networking-2.html">DNS and DHCP</a>
      <a class="dropdown-item" href="prep-networking-3.html">NAT and Wi-Fi</a>
      <div class="dropdown-divider"></div>
      <a class="dropdown-item disabled"><strong>Security</strong></a>
      <a class="dropdown-item" href="prep-security-1.html">Security 1</a>
      <a class="dropdown-item" href="prep-security-2.html">Security 2</a>
      <a class="dropdown-item" href="prep-security-3.html">Security 3</a>
      <a class="dropdown-item" href="prep-security-4.html">Security 4</a>
      <div class="dropdown-divider"></div>
      <a class="dropdown-item disabled"><strong>Internet of Things</strong></a>
      <a class="dropdown-item" href="prep-iot-intro.html">IoT 1: Introduction</a>
      <a class="dropdown-item" href="prep-iot-http-json.html">IoT 2: HTTP and JSON</a>
      <a class="dropdown-item" href="prep-iot-mqtt.html">IoT 3: MQTT</a>
      <a class="dropdown-item" href="prep-iot-api.html">IoT 4: APIs</a>
      <a class="dropdown-item" href="prep-iot-nb-iot.html">NB-IoT (Extra)</a>
    </div>
  </li>
  
  <li class="nav-item dropdown">
    <a class="nav-link dropdown-toggle" data-toggle="dropdown" href="#" role="button" aria-haspopup="true" aria-expanded="false">Activities</a>
    <div class="dropdown-menu">
        <a class="dropdown-item disabled"><strong>Networking</strong></a>
        <a class="dropdown-item" href="networking-1.html">IPs, Subnets and Routing</a>
        <a class="dropdown-item" href="networking-2.html">DNS and DHCP</a>
        <a class="dropdown-item" href="networking-3.html">NAT and Wi-Fi
        <div class="dropdown-divider"></div>
        <a class="dropdown-item disabled"><strong>Security</strong></a>
        <a class="dropdown-item" href="security-1.html">Security 1</a>
        <a class="dropdown-item" href="security-2.html">Security 2</a>
        <a class="dropdown-item" href="security-3.html">Security 3</a>
        <a class="dropdown-item" href="security-4.html">Security 4</a>
        <div class="dropdown-divider"></div>
        <a class="dropdown-item disabled"><strong>Internet of Things</strong></a>
        <a class="dropdown-item" href="iot-http-json.html">HTTP and JSON</a>
        <a class="dropdown-item" href="iot-lorawan.html">LoRaWAN / NB-IoT</a>
        <a class="dropdown-item" href="iot-mqtt.html">MQTT</a>
        <a class="dropdown-item" href="iot-api.html">API</a>
      </div>
  </li>
  
  <li class="nav-item dropdown">
    <a class="nav-link dropdown-toggle" data-toggle="dropdown" href="#" role="button" aria-haspopup="true" aria-expanded="false">Material</a>
    <div class="dropdown-menu">
      <a class="dropdown-item" href="commands-help.html">Help on Commands</a>
      <a class="dropdown-item" href="commands.html">List of Commands</a>
      <a class="dropdown-item" href="computer-history.html">Extra Videos</a>
    </div>
  </li>
  
  <li class="nav-item dropdown">
    <a class="nav-link dropdown-toggle" data-toggle="dropdown" href="#" role="button" aria-haspopup="true" aria-expanded="false">Learning</a>
    <div class="dropdown-menu">
      <a class="dropdown-item" href="feedback.html">Tilbakemelding</a>
      <a class="dropdown-item" href="reports.html">Rapporter</a>
      <a class="dropdown-item" href="working-in-teams.html">Working in Teams</a>
      <a class="dropdown-item" href="smash.html">Finding the Smash Lab</a>
    </div>
  </li>
  
  <!--
  <li class="nav-item">
    <a class="nav-link" href="#">Blackboard</a>
  </li>-->
</ul>

<div class="navbar-nav flex-row ml-md-auto d-none d-md-flex"></div>
             <a class="navbar-brand" href="https://ntnu.edu">
      	<svg width="100" height="30">
      		<image xlink:href="https://innsida.ntnu.no/innsida-theme/images/ntnu-graphics/ntnu_logo_white.svg" 
      		src="https://innsida.ntnu.no/innsida-theme/images/ntnu-graphics/ntnu_logo_white.png" width="100%" height="100%"></image>
      	</svg>
      </a>
    </nav>


<div class="page">
    </section>
    <section class="content">
<h1 id="mqtt">MQTT</h1>
<p>This week, you will learn how to communicate by using a protocol that is called <strong>MQTT</strong>. Like HTTP, it is usually executed on top of TCP/IP, but you will notice that this protocol is very different from HTTP, in many respects. That’s one of the reasons why we look at it. Once you have understood HTTP and MQTT, you have covered a lot of mechanisms, properties, patterns and architectures that are used in communication protocols.</p>
<h2 id="learning-goals">Learning Goals</h2>

<p>Goals: After this week, you will be able to:</p>
<ul>
<li>Run and operate your own MQTT broker.</li>
<li>Create an MQTT client in Python.</li>
<li>Publish and receive messages, including data payload.</li>
<li>Select proper quality-of-service levels.</li>
<li>Design MQTT topics for applications.</li>
</ul>

    </section>
    <section class="content">
<h1 id="mqtt">MQTT</h1>
<p>MQTT is often used in situations where events should be sent from many sensors and broadcast to several applications. IBM and others for instance use MQTT so that IoT devices can send updates into their cloud. When Facebook introduced their standalone Messenger application, they also relied on MQTT to push messages to the clients.[^1]</p>
<p>MQTT is pretty easy to work with, and the following are my personal top 5 reasons why using MQTT is interesting:</p>
<ol type="1">
<li><strong>MQTT is simple to debug.</strong> You can have extra clients during development that observe all communication. You can also manually send messages. This makes debugging much easier.</li>
<li><strong>You only need handle one IP address.</strong> That is the address of the broker. All other addressing happens indirectly via topics.</li>
<li><strong>Application startup is simple.</strong> You have to start the MQTT broker first, but clients can then connect in any order. The MQTT broker can also be hosted on a server and be always-on.</li>
<li><strong>MQTT works also behind a NAT.</strong> This means you can push a message from any location to a computer that is connected to your router at home. Only the broker needs to be accessible.</li>
<li><strong>MQTT is bi-directional by default.</strong> Any client can send messages to any other client, at any time. You are not restricted to a client-server structure where only the client can initiate interactions.</li>
</ol>
<h2 id="broker-architecture">Broker Architecture</h2>
<p>MQTT is a protocol that is based on the <strong>client-broker</strong> topology. As a repetition, remember first the client-server architecture, as we have it for instance in HTTP:</p>
<p><strong>Client-server:</strong></p>

<div class="   the client knows the address of the server. the server gets to know"><p>the client only after the client makes initial contact. Since only the client knows the address of the server initially, it is only the clients that can make the first contact and take initiative. In the world wide web, servers can host web sites and are contacted by browsers (the clients.) This is an example where there are many clients and only few servers, and where servers are optimized to server many clients. But there are also protocols in which the server is on a tiny sensor device, and “serves” the values of the sensor to any client that is interested in them.</p>
<p><strong>Example:</strong> Assume again a home automation system, in which a controller adjusts the heater (on/off) based on the temperature reported by several sensors that are distributed in the room. With HTTP, the two communication parts were client and servers, and the client can send data to the server or request data via the request-response pattern. We have hence two possibilities, depending on how we assign the roles of client and server:</p>
<ul>
<li><p><strong>HTTP, sensors act as clients:</strong> The sensors are HTTP clients and repeatedly send their temperature measurements to the heater, which is acts as a HTTP server.</p></li>
<li><p><strong>HTTP, sensors act as servers:</strong> Vice-versa, we can think of a solution where each temperature sensor is a HTTP server, and the heater acts as a client. The heater makes requests to each sensor and asks for the current temperature, and then adjusts the heater based on all of the responses.</p></li>
</ul>
<p>Assume now that not only the heater module is interested in the temperature, but also the controller for the window blinds. (If it gets very warm during the summer, it could move down the blinds to keep the sun down.) With the above solutions, how would that look like?</p>
<ul>
<li><p>If the sensors should be the clients, then we now have to update all the sensor logic so that they not only send their measurements to the heater, but also the blind controller. Even worse, since all transmission cost energy, we roughly doubled the energy consumption of the sensor nodes, since the communication doubled. This makes that the batteries only last half as long!</p></li>
<li><p>If the sensors act as HTTP servers and we introduce the blind controller, they don’t have to change their code. They just answer now double as many requests; the ones from the heater and the ones from the blind controller. For the battery life this is equally bad as the solution above.</p></li>
</ul>
<p>The problem with the above scenario is that we used a direct communication between the sensors and the control units, as shown in the figure below. Each sensor (in red) is connected to each controller.</p>
</div>
<div class="figure">
<img src="figures/iot/mqtt-without-broker.svg" alt="This architecture connects each sensor with each client, which is not suitable." width="100%"/>
<span name="figures/iot/mqtt-without-broker.svg">&nbsp;</span>
<aside name="figures/iot/mqtt-without-broker.svg"><p><p>This architecture connects each sensor with each client, which is not suitable.</p>
</p></aside>
</div>
<p>Now imagine a system where the components are more separate form each other, and do not communicate directly with each other. We can achieve this by introducing a component that decouples the sensors and the controllers. We call that component a <strong>broker</strong>, shown in the figure below:</p>

<div class="figure">
<img src="figures/iot/mqtt-with-broker.svg" alt="This architecture introduces a broker, and sensors only connect to this broker." width="100%"/>
<span name="figures/iot/mqtt-with-broker.svg">&nbsp;</span>
<aside name="figures/iot/mqtt-with-broker.svg"><p><p>This architecture introduces a broker, and sensors only connect to this broker.</p>
</p></aside>
</div>
<p><strong>Client-broker:</strong></p>

<div class="   a message broker is a server that distributes messages. the message"><p>broker usually does not care about the specific application or the content of the message. Clients communicate with the server and send messages to the broker, which then get distributed to those clients that are interested in the events.</p>
</div>
<h2 id="mqtt-brokers">MQTT Brokers</h2>
<p>The broker is a generic component, which means that it is not specific for any application and that you can use the same broker for many different applications. You hence don’t need to write your own broker, but can use an existing one and just configure it. There are several MQTT brokers available. The one we are going to use is called <strong>Mosquitto</strong>.</p>

<h2 id="message-patterns-publish-subscribe">Message Patterns: Publish-Subscribe</h2>
<p>MQTT uses a <strong>publish-subscribe</strong> message pattern.</p>
<ul>
<li><p>The <strong>publish</strong> part is very simple: Whenever a client (here a sensor) makes some obervation, it sends a message to the broker. We also say that the client <em>publishes</em> a message, or that the client acts as a publisher.</p></li>
<li><p>The <strong>subscribe</strong> part works as follows: Clients that are interested in a certain information <em>subscribe</em> to the broker. Whenever another client publishes that information, the broker forwards this message to all clients that have subscribed.</p></li>
</ul>
<p>A minimal interaction looks as follows:</p>

<div class="figure">
<img src="figures/iot/mqtt-basic.svg" width="100%"/>
</div>
<p>In MQTT, clients can be publishers or subscribers, or both. There can be any number of subscribers and any number of publishers in a system. Because of the publish-subscribe pattern, the subscribers do not have to know about the publishers, and the publishers do not have to know of the subscribers. They only have to know the address of the MQTT broker and connect to it.</p>
<p>For our home automation system, this enables an elegant and efficient solution: The sensors at as publishing clients that send their measurements to the broker. The controllers act as subscriber clients that subscribe to the broker for temperature updates. Once the broker receives the temperature updates, it forwards them to the controllers. When adding a new controller, it can just be a new subscriber that subscribes to the broker, but the communication and the behavior of the sensors does not change. Also, each sensor sends every measurement only once (to the broker), which helps to save energy.</p>
<p>Below you seen an example with two subscribers. Only subscriber 2 receives the first published message. Subscriber 1 only receives it after it also subscribes.</p>

<div class="figure">
<img src="figures/iot/mqtt-publish-subscribe.svg" width="100%"/>
</div>
<p>#Topics</p>
<p>Topics are used to define which information a subscriber is interested in, and match it with the information publishers provide. Usually, subscribers are not interested in all messages that all publishers send. Subscribers therefore only subscribe to specific topics, which depend on the application. The topics are organized in a hierarchy, separated by a dash (“/”). The following is an example for topics that an application for home automation can use:</p>
<pre><code>house/garage/lights/l1
house/garage/lights/l2
house/garage/sensors/pi1
house/garage/doors/d1</code></pre>
<p>The light <em>l1</em> for instance subscribes to the topic <code>house/garage/lights/l1</code> so that it can receive messages that switch it on or off. The passive infrared sensor <em>pi1</em> publishes messages to the topic <code>house/garage/sensors/pi1</code> every time it detects a movement.</p>
<p>Topics can include wildcards, which make it possible for a subscriber to subscribe to several topics with a single pattern:</p>
<ul>
<li>The “+” is used as a wildcard for a single level</li>
<li>The “#” is used as a wildcard for several levels. It must only be placed at the end of a topic pattern.</li>
</ul>
<p>Examples:</p>
<ul>
<li>To receive all messages sent within the house, a subscriber can subscribe to <code>house/#</code></li>
<li>To receive all messages for lights in any zone (garage or kitchen), a subscriber can subscribe to <code>house/+/lights/+</code></li>
</ul>
<p><strong>Exercise:</strong> A publisher sends a message to the topic <code>a/b/c/d</code>. Which of the following 15 subscription topics will receive this message?</p>
<div>
<table class="table table-sm">
<caption style>
</caption>
<thead>
<tr class="row-1">
<th>
</th>
<th>
Subscription Topic
</th>
</tr>
</thead>
<tbody class="row-hover">
<tr class="row-1">
<td class="column-1">
1
</td>
<td class="column-2">
<pre>#</pre>
</td>
</tr>
<tr class="row-2">
<td class="column-1">
2
</td>
<td class="column-2">
<pre>+/+/+</pre>
</td>
</tr>
<tr class="row-3">
<td class="column-1">
3
</td>
<td class="column-2">
<pre>+/+/+/+</pre>
</td>
</tr>
<tr class="row-4">
<td class="column-1">
4
</td>
<td class="column-2">
<pre>+/b/c/#</pre>
</td>
</tr>
<tr class="row-5">
<td class="column-1">
5
</td>
<td class="column-2">
<pre>+/b/c/d</pre>
</td>
</tr>
<tr class="row-6">
<td class="column-1">
6
</td>
<td class="column-2">
<pre>a/#</pre>
</td>
</tr>
<tr class="row-7">
<td class="column-1">
7
</td>
<td class="column-2">
<pre>a/+/+/d</pre>
</td>
</tr>
<tr class="row-8">
<td class="column-1">
8
</td>
<td class="column-2">
<pre>a/+/c/d</pre>
</td>
</tr>
<tr class="row-9">
<td class="column-1">
9
</td>
<td class="column-2">
<pre>a/b/#</pre>
</td>
</tr>
<tr class="row-10">
<td class="column-1">
10
</td>
<td class="column-2">
<pre>a/b/c</pre>
</td>
</tr>
<tr class="row-11">
<td class="column-1">
11
</td>
<td class="column-2">
<pre>a/b/c/#</pre>
</td>
</tr>
<tr class="row-12">
<td class="column-1">
12
</td>
<td class="column-2">
<pre>a/b/c/d/#</pre>
</td>
</tr>
<tr class="row-13">
<td class="column-1">
13
</td>
<td class="column-2">
<pre>a/b/c/d</pre>
</td>
</tr>
<tr class="row-14">
<td class="column-1">
14
</td>
<td class="column-2">
<pre>b/+/c/d</pre>
</td>
</tr>
<tr class="row-15">
<td class="column-1">
15
</td>
<td class="column-2">
<pre>a/b/c/d/+</pre>
</td>
</tr>
</tbody>
</table>
</div>

<h2 id="example">Example</h2>
<p>An application to switch on the lights whenever a movement is detected can work like this: (In pseudo code)</p>
<pre><code>subscribe to house/garage/sensors/pi1
whenever an MQTT messages arrives at house/garage/sensors/pi1:
    send a message 
        to house/garage/lights/l1 with payload &quot;on&quot;
    
    after some time, send a message
        to house/garage/lights/l1 with payload &quot;off&quot;</code></pre>

<h2 id="quality-of-service">Quality of Service</h2>
<p>Messages can be sent with three different quality-of-service (QoS) flags, which determine how much effort the broker and the clients spend on sending them:</p>
<ul>
<li><p>QoS=0 is also called <em>At most once</em>. The message can get lost, and there will be no attempts to resend it.</p></li>
<li><p>QoS=1 is also called <em>At least once</em>. This means that the message will be eventually received, but that several copies of the message may appear due to duplication. The receiver has to detect any such duplicates.</p></li>
<li><p>QoS=2 is also called <em>Exactly once</em>. This guarantees the delivery and avoids any duplication.</p></li>
</ul>
<p><strong>You may ask:</strong> <em>If QoS=2 is available, why would one ever use any of the lower QoS levels?</em></p>
<p>The answer is that the highest quality of service is also more expensive with regards to transmission effort. To send a single QoS=2 message, several messages on the underlying channel are necessary. Therefore, an application should always choose the lowest QoS level it can work with.</p>
<p>Below you see the diagrams that show how many control packages are involved to just send a single MQTT message, using QoS = 0.</p>

<div class="figure">
<img src="figures/iot/mqtt-qos-0.svg" width="100%"/>
</div>
<p>For QoS=2, the protocol uses more control messages to transport a single MQTT message. This shows that there are more control messages involved the higher the QoS level is. This also means that it is more expensive for the network to transport MQTT messages with higher QoS level, as it uses more resources.</p>

<div class="figure">
<img src="figures/iot/mqtt-qos-2.svg" width="100%"/>
</div>
    </section>
    <section class="content">
<h1 id="mqtt-clients-in-python">MQTT Clients in Python</h1>
<p>There are libraries to use MQTT in a variety of programming languages. For Python, there is a library for an MQTT client called <em>Paho</em>. As usual, you install it via pip, using <code>pip install paho-mqtt</code></p>
<h2 id="mqtt-subscriber-client">MQTT Subscriber Client</h2>
<p>The code for a client that subscribes to a topic looks like this:</p>
<pre><code>import paho.mqtt.client as mqtt               
client.connect(&#39;iot.eclipse.org&#39;, 1883, 60)   </code></pre>
<p>The code above is in its structure similar to the one we used when creating our own HTTP server. Here, we connect to a public MQTT broker of the Eclipse IoT project. The default port is 1883. The argument 60 denotes the number of seconds of maximum silence. If no message is sent within this time, the client sends automatically a ping message, so that the broker still knows that the client is alive.</p>
<p>The subscription happens in the callback function <code>on_connect()</code>. This has the benefit that the client will subscribe whenever it connects successfully. Paho has a built-in reconnection function, i.e., when the client disconnects it tries to connect again. When the subscription happens in the connect function, the subscription is also restored.[^2]</p>
<h2 id="mqtt-publisher-client">MQTT Publisher Client</h2>
<p>The following code is used to publish a message:</p>
<pre><code>client.publish(topic, payload=None, qos=0, retain=False)</code></pre>

    </section>
    <section class="content">
<h1 id="debugging-with-mqtt.fx">Debugging With MQTT.Fx</h1>

<div class="figure">
<img src="figures/iot/mqtt-fx.png" width="100%"/>
</div>
<p>MQTT.FX[^3] is a tool useful during development. Using MQTT.FX is really simple, but because we have now talked about brokers, clients, publishers and subscribers, you may loose track and wonder what this MQTT.FX does: Think of it as a debugger for MQTT, and you can use it like Wireshark. Once the system is done, you don’t need MQTT.FX anymore.</p>
<p>Essentially, MQTT.FX is a MQTT client, and can as such connect to an MQTT broker, subscribe to topics and send messages to topics. This does not sound like much. However, MQTT.FX has a generic user interface, you can use MQTT.FX while you construct your application to see how the other system components publish messages, and you can also &quot;inject&quot; messages into the system, by publishing to any topic you want.</p>

<div class="figure">
<img src="figures/iot/mqtt-fx-publish.png" width="100%"/>
</div>
<h2 id="publishing-messages">Publishing Messages</h2>
<p>Imagine you have created a MQTT client that runs a certain action when it receives a message, but you are not doen with the component that should send the message. To test at least the component that should receive the message, you can use MQTT.FX to publish a message with that content to the topic, and the component under test will behave as if the message was sent in the final system.</p>

<div class="figure">
<img src="figures/iot/mqtt-fx-subscribe.png" width="100%"/>
</div>
<h2 id="observing-communication">Observing Communication</h2>
<p>Because MQTT uses the publish-subscribe pattern, it can simply subscribe to any topics that are interesting in your application and you can see which messages are sent to these topics, without disturbing the communication in the system. To achieve the same in HTTP, for instance, you need a tool like Wireshark.</p>

    </section>
</div>


<footer></footer>
</body>
</html>
